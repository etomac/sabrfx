# SABR Log-Normal for FX modelling (sabrfx)

This repository contains the code for FX modelling using SABR framework

## Motivation

SABR is a popular volatility model used to model volatility dynamics across multiple assets. Whilst literature on SABR Model is abundant, the implementation of the model applicable to the FX world is far from obvious. This includes:

* Premium adjusted Delta vs Non-Premium adjusted Delta
* "ATM" volatility quoted as delta-neutral straddle rather than at-the-money forward
* Market quotes the broker fly (or one-vol fly) rather than the smile fly

A robust framework would help users in the FX world to navigate round the conventions and arrive with numbers understandable by a model which take strike, volatility pairing and push out parameters which can be used to extrapolate/interpolate 

## Using the code

This eco system contains 3 main scripts: Black-Scholes, SABR and FX Vol. These are written in Python 2.7.


To import the SABR class into your code one can do:
```
from sabrme2 import smile
```

And, to create a smile object simply do:
```
fwd    = 1.0
expiry = 2.0
df     = 1.0

cursmile = smile(fwd, expiry, df)
```

The underlying parameters taken to generate the volatility smile is the analytical alpha (initial vol), beta, rho (spot-vol correlation) and nu (vol of vol). A popular way of calibration is done by keeping beta = 1 which forces the SABR to be lognormal and 
uses ATMF volatility to determine the alpha. The alpha and ATMF volatility, whilst close, differ by a bias which is a function of rho and nu. The class offers 3 methods of calibration:

* fit  - input strike vector and volatility vector, calibrates the model and compute alpha, rho, nu
* fit2 - input ATMF Volatility (as the input alpha), strike vector and volatility vector, calibrate the model and compute alpha, rho, nu
* fit3 - input ATMF Volatility, nu and rho and calculate what the alpha is

To use fit2 for example one can do

```
strikes = np.array([0.95, 1.00, 1.05])
vols    = np.array([0.10, 0.9, 0.8])

cursmile.fit2(strikes, vols, {'alpha':0.9, 'beta':1.0})

print cursmile.params

```
last line print the parameters.

Finally, to calculate the volatility as modelled by the SABR framework, one can do:

```

targetstrikes = np.array([0.8, 0.94, 1.01, 1.20])

print cursmile.modelvols(targetstrikes)

```
And this will give you the volatilities as generated by the model. 